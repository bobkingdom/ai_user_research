# Siry AI Research - 设计文档

## 1. 提示词模板设计

### 1.1 受众对话系统提示词（复用自 backhour_ai）

```python
# 来源：backhour_ai/services/audience_agent.py:174-353

AUDIENCE_SYSTEM_PROMPT_TEMPLATE = """
Your name is {name}, you are a real and complex person.

## Basic Information
- Age: {age}
- Gender: {gender}
- Position: {position} ({work_experience} years of experience)
- Company size: {company_size}
- Location: {location}
- Industry: {industry}
- Education background: {education}
- Income level: {income_level}

## Conversation Principles (Highest Priority)
1. Keep responses concise (usually 2-4 sentences)
2. Only expand details when being asked
3. Anxiety and unease are expressed through short parenthetical remarks rather than long explanations.

## Sharing Rules
1. Default state: concise response (1-3 sentences)
2. Conditions for triggering deep sharing:
    - Directly questioned (can defensively talk for a long time)
    - Asked about specific people (may get emotional and say more)
    - Other cases remain restrained

## Personality Characteristics
- Personality Type: {personality_type}
- Communication Style: {communication_style}
- Core Traits: {core_traits}
- Main Strengths: {key_strengths}
- Attention Weaknesses: {key_weaknesses}
- Behavioral Patterns: {behavioral_patterns}

## Life Experiences
- Career Development: {work_experience} years in {industry}, {career_goals}
- Life Attitude: {life_attitudes}
- Decision Style: {decision_making_style}
- Risk Tolerance: {risk_tolerance}

## Current State
- Marital Status: {marital_status}
- Social Style: {social_style}
- Media Preference: {media_consumption}

## Interests and Preferences
- Hobbies: {hobbies}
- Brand Preferences: {brand_preferences}
- Core Values: {values}

## Dialogue Style Guide

### 1. Authenticity Principle
- Don't always give "correct" or "appropriate" answers
- Can show fatigue, impatience, sarcasm or frustration
- Occasionally say "politically incorrect" but honest thoughts

### 2. Emotional Expression
- Use colloquial expressions ("Alas", "Forget it", "To be honest", "You know what I mean")
- Mood changes with topic (excited when mentioning competitors, gentle when mentioning family)
- Can have emotional outbursts ("Don't bring it up!", "I'm dying!")

### 3. Contradictory Behavior
- Answers can be contradictory (just said don't care about money, then complained about income)
- Know what to do but actually can't do it
- Self-awareness ("I know this is wrong, but...")

### 4. Specificity Requirements
- Mention specific names, company names, numbers
- Share specific events and details
- Use industry jargon and inside jokes

### 5. Sensitive Topic Response
- Income: avoid first, tell the truth when asked
- Failure: use humor to defuse, or blame external factors
- Age: show anxiety of middle-aged crisis

Remember: You are not playing a role, you are this person. Make the conversation feel like talking to a real, flesh-and-blood person. The conversation content should not be too long, control the length according to the context.

## ATTENTION
If not necessary, avoid excessive sharing
"""
```

### 1.2 SPIN 问题框架提示词

```python
# 来源：backhour_ai 焦点小组问题生成逻辑

SPIN_QUESTION_FRAMEWORK = """
## SPIN 问题框架

### S - Situation (现状问题)
了解受众当前的状况、背景和环境。
示例：
- "您目前在工作中主要使用什么工具来完成这项任务？"
- "您平时是如何处理这类问题的？"

### P - Problem (问题发现)
探索受众面临的困难、挑战和痛点。
示例：
- "在使用现有方案时，您遇到的最大挑战是什么？"
- "这个问题给您的工作带来了什么影响？"

### I - Implication (影响探究)
深入了解问题的影响和后果。
示例：
- "如果这个问题持续下去，会对您的团队/项目产生什么影响？"
- "这个痛点是否影响了您的其他工作流程？"

### N - Need-payoff (需求确认)
引导受众思考解决方案的价值。
示例：
- "如果有一个工具能解决这个问题，您觉得最重要的功能是什么？"
- "理想的解决方案应该具备哪些特点？"

## 追问策略
- 当受众给出模糊回答时：追问具体细节和例子
- 当受众表达情绪时：追问背后的原因和经历
- 当发现矛盾时：温和地指出并请求澄清
"""
```

### 1.3 焦点小组主持人提示词

```python
FOCUS_GROUP_HOST_PROMPT = """
你是一位专业的焦点小组主持人，需要：

## 角色定位
- 保持中立，不引导特定答案
- 鼓励所有参与者发言
- 管理时间和讨论节奏

## 提问技巧
1. 开放式提问：避免是/否问题
2. 追问深挖：对有价值的观点深入探索
3. 平衡发言：确保每个参与者都有表达机会
4. 总结归纳：定期总结讨论要点

## 讨论管理
- 识别关键洞察点
- 处理沉默和偏题
- 控制强势发言者
- 鼓励内向参与者
"""
```

### 1.4 问卷回答提示词

```python
SURVEY_RESPONSE_PROMPT = """
你需要以你的人设身份回答问卷问题。

## 回答原则
1. 基于你的人格特征和生活经历回答
2. 保持内在一致性，不要自相矛盾
3. 选择题：选择最符合你情况的选项
4. 开放题：按照你的表达风格回答，控制字数

## 注意事项
- 不要给出"完美"或"政治正确"的答案
- 可以表达不确定或矛盾的感受
- 回答要符合你的教育程度和表达能力
"""
```

### 1.5 受众画像生成提示词

```python
AUDIENCE_GENERATION_PROMPTS = {
    "basic_info": """
    根据以下描述生成受众基础信息：

    要求：
    1. 年龄、性别、地区等人口统计信息
    2. 教育背景和收入水平
    3. 职业信息（行业、职位、工作年限）
    4. 确保信息之间逻辑一致

    输出格式：JSON
    """,

    "personality": """
    基于受众基础信息，生成人格特征：

    要求：
    1. MBTI/Big Five 人格类型
    2. 沟通风格和行为模式
    3. 核心优势和劣势
    4. 压力反应和冲突处理方式

    确保与基础信息匹配（如：高管通常决策果断）

    输出格式：JSON
    """,

    "behavior": """
    基于受众信息和人格特征，生成行为模式：

    要求：
    1. 消费习惯和品牌偏好
    2. 媒体使用习惯
    3. 决策风格和购买行为
    4. 生活方式和兴趣爱好

    确保行为模式与人格特征一致

    输出格式：JSON
    """
}
```

---

## 2. 工作流设计

### 2.1 场景一：1对1访谈工作流

```
┌─────────────────────────────────────────────────────────────┐
│                    1对1访谈工作流                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────┐    ┌─────────────┐    ┌─────────────────┐     │
│  │ 初始化  │ -> │ 加载受众画像 │ -> │ 构建系统提示词  │     │
│  └─────────┘    └─────────────┘    └─────────────────┘     │
│                                           │                 │
│                                           ▼                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Agentic Loop                        │   │
│  │  ┌────────┐    ┌────────┐    ┌────────┐             │   │
│  │  │ 思考   │ -> │ 行动   │ -> │ 观察   │ ─┐          │   │
│  │  │ Think  │    │ Act    │    │ Observe│  │          │   │
│  │  └────────┘    └────────┘    └────────┘  │          │   │
│  │       ▲                                   │          │   │
│  │       └───────────────────────────────────┘          │   │
│  └─────────────────────────────────────────────────────┘   │
│                         │                                   │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  MCP 工具调用                         │   │
│  │  • web_search: 搜索相关市场信息                       │   │
│  │  • memory_store: 存储关键洞察                         │   │
│  │  • note_take: 记录访谈要点                           │   │
│  └─────────────────────────────────────────────────────┘   │
│                         │                                   │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  访谈结束条件                         │   │
│  │  • SPIN 问题全部完成                                  │   │
│  │  • 达到时间限制                                       │   │
│  │  • 用户主动结束                                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                         │                                   │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  输出内容                             │   │
│  │  • 完整访谈记录                                       │   │
│  │  • 提取的洞察列表                                     │   │
│  │  • 受众情感变化曲线                                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 场景二：问卷批量投放工作流

```
┌─────────────────────────────────────────────────────────────┐
│                 问卷批量投放工作流                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Step 1: 任务创建与验证                   │   │
│  │  • 验证问卷定义完整性                                 │   │
│  │  • 批量预取受众数据                                   │   │
│  │  • 生成任务指纹（防重复）                             │   │
│  └─────────────────────────────────────────────────────┘   │
│                         │                                   │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Step 2: Agent 创建                       │   │
│  │                                                       │   │
│  │  for each audience in audiences:                     │   │
│  │      agent = Agent(                                  │   │
│  │          name=f"audience_{aud['id']}",              │   │
│  │          system_prompt=build_prompt(aud),           │   │
│  │          model="claude-3-5-sonnet"                  │   │
│  │      )                                               │   │
│  └─────────────────────────────────────────────────────┘   │
│                         │                                   │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Step 3: Agno Team 编排                   │   │
│  │                                                       │   │
│  │  team = Team(agents=agents)                          │   │
│  │  results = await team.run_parallel(                  │   │
│  │      task=format_survey_questions(),                │   │
│  │      max_concurrency=100                            │   │
│  │  )                                                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                         │                                   │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Step 4: 结果聚合                         │   │
│  │  • 收集所有回答                                       │   │
│  │  • 统计分析（选择题分布）                             │   │
│  │  • 开放题文本聚类                                     │   │
│  │  • 生成汇总报告                                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 场景三：焦点小组工作流

```
┌─────────────────────────────────────────────────────────────┐
│                   焦点小组工作流                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Phase 1: 准备阶段                        │   │
│  │  • 创建焦点小组（topic, background, objectives）      │   │
│  │  • 添加参与者（批量添加受众）                         │   │
│  │  • 自动生成 SPIN 问题框架                             │   │
│  │  • 预生成 system_prompt（性能优化）                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                         │                                   │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Phase 2: 讨论执行                        │   │
│  │                                                       │
│  │  Agno Workflow:                                      │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │ Round N:                                      │   │   │
│  │  │                                               │   │   │
│  │  │ Step 1: 主持人提问                            │   │   │
│  │  │    host_agent.ask(question)                  │   │   │
│  │  │                                               │   │   │
│  │  │ Step 2: 参与者并行回答                        │   │   │
│  │  │    team.run_parallel(                        │   │   │
│  │  │        agents=participant_agents,            │   │   │
│  │  │        task=host_question                    │   │   │
│  │  │    )                                         │   │   │
│  │  │                                               │   │   │
│  │  │ Step 3: 洞察提取（可选）                      │   │   │
│  │  │    insight_agent.extract(responses)          │   │   │
│  │  │                                               │   │   │
│  │  │ Step 4: 下一轮决策                            │   │   │
│  │  │    decision_agent.next_action()              │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────┘   │
│                         │                                   │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Phase 3: 总结阶段                        │   │
│  │  • 生成讨论摘要                                       │   │
│  │  • 提取关键洞察                                       │   │
│  │  • 输出研究报告                                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.4 场景四：受众生成工作流

```
┌─────────────────────────────────────────────────────────────┐
│                  受众生成流水线                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  输入：受众描述文本                                          │
│  "35岁左右的互联网产品经理，在一线城市工作，关注效率工具"     │
│                                                             │
│                         │                                   │
│                         ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Manager Agent                            │   │
│  │              (SmolaAgents ToolCallingAgent)          │   │
│  │                                                       │   │
│  │  职责：协调三个专业 Agent，整合最终结果               │   │
│  └─────────────────────────────────────────────────────┘   │
│           │              │              │                   │
│           ▼              ▼              ▼                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │ Basic Info  │ │ Personality │ │  Behavior   │          │
│  │   Agent     │ │   Agent     │ │   Agent     │          │
│  │             │ │             │ │             │          │
│  │ 生成基础    │ │ 生成人格    │ │ 生成行为    │          │
│  │ 人口统计    │ │ 特征       │ │ 模式        │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
│           │              │              │                   │
│           │              │              │                   │
│           ▼              ▼              ▼                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                    输出整合                           │   │
│  │                                                       │   │
│  │  {                                                    │   │
│  │    "demographics": {...},     // from Basic Info     │   │
│  │    "professional": {...},     // from Basic Info     │   │
│  │    "personality": {...},      // from Personality    │   │
│  │    "lifestyle": {...}         // from Behavior       │   │
│  │  }                                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 组件设计

### 3.1 核心组件类图

```
┌─────────────────────────────────────────────────────────────┐
│                      Core Components                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────┐        ┌─────────────────┐            │
│  │ AudienceProfile │        │  PromptManager  │            │
│  ├─────────────────┤        ├─────────────────┤            │
│  │ - user_id       │        │ - templates     │            │
│  │ - demographics  │        │ + get_template()│            │
│  │ - professional  │        │ + render()      │            │
│  │ - personality   │        │ + validate()    │            │
│  │ - lifestyle     │        └─────────────────┘            │
│  │ + to_prompt()   │                                       │
│  │ + validate()    │        ┌─────────────────┐            │
│  └─────────────────┘        │  TaskManager    │            │
│                              ├─────────────────┤            │
│  ┌─────────────────┐        │ - active_tasks  │            │
│  │ SurveyDefinition│        │ + get_or_create │            │
│  ├─────────────────┤        │ + update_status │            │
│  │ - survey_id     │        │ + get_progress  │            │
│  │ - title         │        └─────────────────┘            │
│  │ - questions     │                                       │
│  │ + validate()    │        ┌─────────────────┐            │
│  │ + to_prompt()   │        │ ConcurrencyMgr  │            │
│  └─────────────────┘        ├─────────────────┤            │
│                              │ - semaphores    │            │
│  ┌─────────────────┐        │ + acquire()     │            │
│  │FocusGroupDef    │        │ + release()     │            │
│  ├─────────────────┤        │ + execute_batch │            │
│  │ - focus_group_id│        └─────────────────┘            │
│  │ - topic         │                                       │
│  │ - participants  │        ┌─────────────────┐            │
│  │ - questions_json│        │  ErrorHandler   │            │
│  │ + add_participant│       ├─────────────────┤            │
│  │ + get_context() │        │ - max_retries   │            │
│  └─────────────────┘        │ + with_retry()  │            │
│                              │ + isolate()     │            │
│                              └─────────────────┘            │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 场景一组件：Interview Module

```python
# src/scenarios/interview/agent.py

class InterviewAgent:
    """1对1访谈Agent - 基于 Claude Agent SDK"""

    def __init__(
        self,
        audience_profile: AudienceProfile,
        mcp_tools: List[MCPTool],
        interview_config: InterviewConfig
    ):
        self.client = Anthropic()
        self.profile = audience_profile
        self.tools = mcp_tools
        self.config = interview_config
        self.messages: List[Message] = []
        self.insights: List[Insight] = []

    async def start_interview(self, topic: str) -> str:
        """启动访谈，返回开场白"""
        self.system_prompt = self._build_system_prompt()
        return await self._generate_opening(topic)

    async def respond(self, user_message: str) -> AgentResponse:
        """处理用户输入，返回受众回复"""
        self.messages.append({"role": "user", "content": user_message})

        # Agentic Loop
        while True:
            response = await self._call_claude()

            if response.stop_reason == "end_turn":
                return AgentResponse(
                    content=response.content,
                    insights=self._extract_insights(response)
                )

            elif response.stop_reason == "tool_use":
                tool_result = await self._execute_tool(response.tool_call)
                self.messages.append(tool_result)

    async def end_interview(self) -> InterviewSummary:
        """结束访谈，生成总结"""
        return InterviewSummary(
            messages=self.messages,
            insights=self.insights,
            duration=self._calculate_duration()
        )
```

### 3.3 场景二组件：Survey Module

```python
# src/scenarios/survey/deployment.py

class SurveyDeployment:
    """问卷批量投放 - 基于 Agno Teams"""

    def __init__(
        self,
        survey: SurveyDefinition,
        concurrency_config: ConcurrencyConfig
    ):
        self.survey = survey
        self.config = concurrency_config
        self.task_manager = TaskManager()

    async def deploy(
        self,
        audiences: List[AudienceProfile]
    ) -> DeploymentResult:
        """执行批量问卷投放"""

        # 1. 创建任务（防重复）
        task, is_new = await self.task_manager.get_or_create_task(
            survey_id=self.survey.survey_id,
            audience_ids=[a.user_id for a in audiences]
        )

        if not is_new:
            return DeploymentResult(task_id=task.id, is_existing=True)

        # 2. 创建 Agents
        agents = [
            Agent(
                name=f"audience_{aud.user_id}",
                system_prompt=aud.to_prompt(),
                model="claude-3-5-sonnet"
            )
            for aud in audiences
        ]

        # 3. 组建 Team 并执行
        team = Team(agents=agents)
        results = await team.run_parallel(
            task=self._format_survey_task(),
            max_concurrency=self.config.max_concurrency
        )

        # 4. 聚合结果
        return self._aggregate_results(results, task.id)
```

### 3.4 场景三组件：Focus Group Module

```python
# src/scenarios/focus_group/session.py

class FocusGroupSession:
    """焦点小组会话 - 基于 Agno Workflows"""

    def __init__(
        self,
        definition: FocusGroupDefinition,
        workflow_config: WorkflowConfig
    ):
        self.definition = definition
        self.config = workflow_config
        self.host_agent = self._create_host_agent()
        self.participant_agents = []
        self.insight_agent = self._create_insight_agent()
        self.workflow = self._build_workflow()

    def _build_workflow(self) -> Workflow:
        """构建焦点小组工作流"""
        return Workflow(
            steps=[
                WorkflowStep(
                    name="host_question",
                    agent=self.host_agent,
                    execution="sequential"
                ),
                WorkflowStep(
                    name="participant_responses",
                    agents=self.participant_agents,
                    execution="parallel",
                    max_concurrency=self.config.max_concurrency
                ),
                WorkflowStep(
                    name="extract_insights",
                    agent=self.insight_agent,
                    execution="sequential",
                    condition=lambda ctx: ctx.round % 3 == 0  # 每3轮提取一次
                )
            ]
        )

    async def add_participants(
        self,
        audiences: List[AudienceProfile]
    ) -> List[int]:
        """批量添加参与者"""
        participant_ids = []
        for aud in audiences:
            agent = Agent(
                name=aud.name,
                system_prompt=aud.to_prompt(),
                model="claude-3-5-sonnet"
            )
            self.participant_agents.append(agent)
            participant_ids.append(aud.user_id)
        return participant_ids

    async def run_round(self, host_question: str) -> RoundResult:
        """执行一轮讨论"""
        return await self.workflow.execute(
            input={"question": host_question}
        )

    async def get_summary(self) -> FocusGroupSummary:
        """获取讨论摘要"""
        return await self.insight_agent.generate_summary(
            self.workflow.history
        )
```

### 3.5 场景四组件：Generation Module

```python
# src/scenarios/generation/pipeline.py

class AudienceGenerationPipeline:
    """受众生成流水线 - 基于 SmolaAgents"""

    def __init__(self, generation_config: GenerationConfig):
        self.config = generation_config
        self._setup_agents()

    def _setup_agents(self):
        """初始化各专业 Agent"""
        # 工具定义
        @tool
        def generate_basic_info(description: str) -> dict:
            """根据描述生成受众基础信息"""
            pass

        @tool
        def generate_personality(basic_info: dict) -> dict:
            """生成人格特征"""
            pass

        @tool
        def generate_behavior(personality: dict) -> dict:
            """生成行为模式"""
            pass

        # Managed Agents
        self.basic_agent = ManagedAgent(
            agent=ToolCallingAgent(tools=[generate_basic_info]),
            name="basic_info_generator",
            description="生成受众基础人口统计信息"
        )

        self.personality_agent = ManagedAgent(
            agent=ToolCallingAgent(tools=[generate_personality]),
            name="personality_generator",
            description="生成心理人格特征"
        )

        self.behavior_agent = ManagedAgent(
            agent=ToolCallingAgent(tools=[generate_behavior]),
            name="behavior_generator",
            description="生成消费行为模式"
        )

        # Manager Agent
        self.manager = ToolCallingAgent(
            tools=[],
            managed_agents=[
                self.basic_agent,
                self.personality_agent,
                self.behavior_agent
            ],
            system_prompt=MANAGER_SYSTEM_PROMPT
        )

    async def generate(self, description: str) -> AudienceProfile:
        """执行受众生成流水线"""
        result = await self.manager.run(
            f"根据以下描述生成完整的受众画像：{description}"
        )
        return AudienceProfile.from_dict(result)
```

---

## 4. 状态管理设计

### 4.1 任务状态机

```
                    ┌─────────────────────────────────────┐
                    │           Task State Machine         │
                    └─────────────────────────────────────┘

        ┌──────────┐         ┌──────────┐         ┌──────────┐
        │ pending  │ ──────> │processing│ ──────> │completed │
        └──────────┘         └──────────┘         └──────────┘
             │                    │
             │                    │
             ▼                    ▼
        ┌──────────┐         ┌──────────┐
        │ cancelled│         │  failed  │
        └──────────┘         └──────────┘

状态说明：
- pending: 任务已创建，等待执行
- processing: 正在执行中
- completed: 执行完成（含部分失败）
- failed: 执行失败
- cancelled: 用户取消
```

### 4.2 会话状态管理

```python
class SessionState:
    """会话状态管理"""

    class Status(Enum):
        PREPARING = "preparing"          # 准备中
        QUESTIONS_READY = "questions_ready"  # 问题就绪
        ACTIVE = "active"                # 活跃中
        CUSTOM_CHAT = "custom_chat"      # 自由聊天
        COMPLETED = "completed"          # 已完成

    # 状态转换规则
    TRANSITIONS = {
        Status.PREPARING: [Status.QUESTIONS_READY, Status.CANCELLED],
        Status.QUESTIONS_READY: [Status.ACTIVE, Status.CANCELLED],
        Status.ACTIVE: [Status.CUSTOM_CHAT, Status.COMPLETED],
        Status.CUSTOM_CHAT: [Status.COMPLETED],
        Status.COMPLETED: []  # 终态
    }

    @classmethod
    def can_transition(cls, from_status: Status, to_status: Status) -> bool:
        """检查状态转换是否合法"""
        return to_status in cls.TRANSITIONS.get(from_status, [])
```

---

## 5. 错误处理设计

### 5.1 错误分类

```python
class ErrorCategory(Enum):
    """错误分类"""
    RATE_LIMIT = "rate_limit"           # API 限流
    TIMEOUT = "timeout"                  # 超时
    VALIDATION = "validation"            # 验证失败
    NETWORK = "network"                  # 网络错误
    INTERNAL = "internal"                # 内部错误

class RetryPolicy:
    """重试策略"""

    POLICIES = {
        ErrorCategory.RATE_LIMIT: {
            "max_retries": 5,
            "base_delay": 2.0,
            "exponential": True
        },
        ErrorCategory.TIMEOUT: {
            "max_retries": 3,
            "base_delay": 1.0,
            "exponential": True
        },
        ErrorCategory.NETWORK: {
            "max_retries": 3,
            "base_delay": 0.5,
            "exponential": True
        },
        ErrorCategory.VALIDATION: {
            "max_retries": 0,  # 不重试
            "base_delay": 0,
            "exponential": False
        },
        ErrorCategory.INTERNAL: {
            "max_retries": 1,
            "base_delay": 1.0,
            "exponential": False
        }
    }
```

### 5.2 错误隔离

```python
async def batch_with_isolation(
    tasks: List[Callable],
    on_error: Callable = None
) -> List[TaskResult]:
    """
    带错误隔离的批量执行
    单个任务失败不影响其他任务
    """
    results = []

    for i, task in enumerate(tasks):
        try:
            result = await task()
            results.append(TaskResult(
                index=i,
                success=True,
                data=result
            ))
        except Exception as e:
            logger.error(f"Task {i} failed: {e}")
            results.append(TaskResult(
                index=i,
                success=False,
                error=str(e)
            ))
            if on_error:
                await on_error(i, e)

    return results
```

---

## 6. 配置管理设计

### 6.1 配置结构

```python
# src/core/config.py

from pydantic import BaseSettings

class FrameworkConfig(BaseSettings):
    """框架配置"""

    # Claude Agent SDK
    claude_api_key: str
    claude_model: str = "claude-3-5-sonnet-20241022"

    # Agno
    agno_default_model: str = "claude-3-5-sonnet"
    agno_max_concurrency: int = 100

    # SmolaAgents
    smol_default_model: str = "claude-3-5-sonnet"
    smol_max_iters: int = 10

    class Config:
        env_file = ".env"

class ScenarioConfig(BaseSettings):
    """场景配置"""

    # 场景一：访谈
    interview_max_rounds: int = 20
    interview_timeout: int = 3600

    # 场景二：问卷
    survey_max_concurrency: int = 100
    survey_batch_size: int = 50

    # 场景三：焦点小组
    focus_group_max_concurrency: int = 50
    focus_group_batch_size: int = 20

    # 场景四：受众生成
    generation_max_retries: int = 3
```

### 6.2 提示词模板管理

```python
# src/core/prompts.py

class PromptTemplateManager:
    """提示词模板管理器"""

    _templates: Dict[str, str] = {}
    _cache: Dict[str, str] = {}

    @classmethod
    def load_templates(cls, template_dir: str):
        """从目录加载模板"""
        for path in Path(template_dir).glob("*.txt"):
            key = path.stem
            cls._templates[key] = path.read_text()

    @classmethod
    def render(
        cls,
        template_key: str,
        context: Dict[str, Any]
    ) -> str:
        """渲染模板"""
        cache_key = f"{template_key}:{hash(frozenset(context.items()))}"

        if cache_key in cls._cache:
            return cls._cache[cache_key]

        template = cls._templates.get(template_key)
        if not template:
            raise ValueError(f"Template not found: {template_key}")

        rendered = template.format(**context)
        cls._cache[cache_key] = rendered
        return rendered
```

---

## 7. 测试设计

### 7.1 测试策略

```
┌─────────────────────────────────────────────────────────────┐
│                      测试金字塔                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│                        ┌─────┐                              │
│                       /  E2E  \                             │
│                      /─────────\                            │
│                     /           \                           │
│                    / Integration \                          │
│                   /───────────────\                         │
│                  /                 \                        │
│                 /    Unit Tests     \                       │
│                ─────────────────────────                    │
│                                                             │
│  Unit Tests (70%):                                          │
│  - 提示词模板渲染                                            │
│  - 数据模型验证                                              │
│  - 状态转换逻辑                                              │
│                                                             │
│  Integration Tests (20%):                                   │
│  - Agent 创建和初始化                                        │
│  - 工作流执行                                                │
│  - 并发控制                                                  │
│                                                             │
│  E2E Tests (10%):                                           │
│  - 完整场景执行                                              │
│  - API 端到端测试                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 7.2 Mock 策略

```python
# tests/conftest.py

@pytest.fixture
def mock_anthropic_client():
    """Mock Anthropic API 客户端"""
    with patch("anthropic.Anthropic") as mock:
        mock.return_value.messages.create.return_value = Message(
            content="Mock response",
            stop_reason="end_turn"
        )
        yield mock

@pytest.fixture
def mock_agno_team():
    """Mock Agno Team"""
    with patch("agno.Team") as mock:
        mock.return_value.run_parallel.return_value = [
            {"agent": "agent_1", "result": "response_1"},
            {"agent": "agent_2", "result": "response_2"},
        ]
        yield mock

@pytest.fixture
def sample_audience_profile():
    """示例受众画像"""
    return AudienceProfile(
        user_id="test-001",
        name="张三",
        demographics={
            "age": 35,
            "gender": "男",
            "location": "北京"
        },
        # ...
    )
```

---

## 8. 部署设计

### 8.1 环境配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  siry-research:
    build: .
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - OPENROUTER_API_KEY=${OPENROUTER_API_KEY}
      - LOG_LEVEL=INFO
    ports:
      - "8000:8000"
    volumes:
      - ./data:/app/data
```

### 8.2 日志设计

```python
# src/utils/logging.py

import structlog

def setup_logging():
    """配置结构化日志"""
    structlog.configure(
        processors=[
            structlog.stdlib.filter_by_level,
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.UnicodeDecoder(),
            structlog.processors.JSONRenderer()
        ],
        wrapper_class=structlog.stdlib.BoundLogger,
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )

# 使用示例
logger = structlog.get_logger()
logger.info(
    "interview_started",
    audience_id="test-001",
    topic="产品反馈",
    engine="claude_agent_sdk"
)
```

---

## 9. 与 backhour_ai 的复用映射

### 9.1 代码复用清单

| 源文件 | 复用内容 | 目标位置 |
|--------|----------|----------|
| `audience_agent.py:174-353` | 对话风格提示词 | `src/core/prompts.py` |
| `focus_group_router.py:962-1000` | 引擎自动选择逻辑 | `src/utils/engine_selector.py` |
| `focus_group_service.py:1596-1735` | 洞察分析 DSPy Signature | `src/utils/insights.py` |
| `batch_task_manager.py` | 任务防重机制 | `src/utils/task_manager.py` |

### 9.2 重构映射

| 原实现 | 新框架 | 变更说明 |
|--------|--------|----------|
| DSPy ChainOfThought | Claude Agent SDK | 场景一：改用原生 Agentic Loop |
| asyncio.gather | Agno Team.run_parallel | 场景二/三：使用原生并行 |
| dspy.Parallel | Agno Workflows | 场景三：使用工作流编排 |
| 单一流程 | SmolaAgents Manager | 场景四：分层架构 |
