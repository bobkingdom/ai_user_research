# AI User Research - 技术架构文档

## 1. 系统架构概览

```
┌─────────────────────────────────────────────────────────────────────┐
│                         AI User Research                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐     │
│  │  场景一：1对1   │  │ 场景二/三：批量 │  │ 场景四：生成    │     │
│  │  受众访谈       │  │ 问卷/焦点小组   │  │ 受众画像        │     │
│  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘     │
│           │                    │                    │               │
│           ▼                    ▼                    ▼               │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐     │
│  │ Claude Agent    │  │     Agno        │  │  SmolaAgents    │     │
│  │     SDK         │  │ Teams+Workflows │  │ Manager Pattern │     │
│  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘     │
│           │                    │                    │               │
│           └────────────────────┼────────────────────┘               │
│                                │                                    │
│                                ▼                                    │
│                    ┌─────────────────────┐                         │
│                    │   统一数据层         │                         │
│                    │ (受众画像/提示词)    │                         │
│                    └─────────────────────┘                         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. 框架技术详解

### 2.1 Claude Agent SDK（场景一）

#### 核心特点
- **Agentic Loop 架构**：自动化的思考-行动-观察循环
- **原生 MCP 支持**：无缝集成工具生态
- **多轮对话管理**：内置上下文记忆

#### 架构模式
```python
# Claude Agent SDK 核心循环
from anthropic import Anthropic

class InterviewAgent:
    def __init__(self, audience_data, mcp_tools):
        self.client = Anthropic()
        self.tools = mcp_tools
        self.messages = []
        self.system_prompt = self._build_system_prompt(audience_data)

    async def run_interview(self, research_topic):
        """执行完整访谈流程"""
        # 1. 开场白
        response = await self._chat("开始访谈开场")

        # 2. SPIN 问题循环
        while not self._should_end_interview():
            # Agentic Loop: 思考 → 行动 → 观察
            response = await self._agentic_step()

            # 工具调用处理
            if response.stop_reason == "tool_use":
                tool_result = await self._execute_tool(response)
                response = await self._continue_with_tool_result(tool_result)

        # 3. 收尾总结
        return await self._conclude_interview()
```

#### MCP 工具集成
```python
# MCP 工具配置示例
mcp_tools = [
    {
        "name": "web_search",
        "description": "搜索最新市场信息",
        "input_schema": {...}
    },
    {
        "name": "memory_store",
        "description": "存储重要洞察到长期记忆",
        "input_schema": {...}
    }
]
```

---

### 2.2 Agno（场景二/三）

#### 核心特点
- **Teams 编排**：多 Agent 协作管理
- **Workflows 流程**：复杂任务流编排
- **原生并行**：`Team.run_parallel()` 支持大规模并发

#### 架构模式 - 问卷投放
```python
from agno import Agent, Team, Workflow

class SurveyDeployment:
    def __init__(self, survey_definition, audiences):
        self.survey = survey_definition
        self.audiences = audiences

    async def deploy(self):
        """批量问卷投放"""
        # 1. 为每个受众创建 Agent
        agents = [
            Agent(
                name=f"audience_{aud['id']}",
                system_prompt=self._build_prompt(aud),
                model="claude-3-5-sonnet"
            )
            for aud in self.audiences
        ]

        # 2. 组建 Team
        team = Team(agents=agents)

        # 3. 并行执行问卷
        results = await team.run_parallel(
            task=self._format_survey_questions(),
            max_concurrency=100
        )

        return self._aggregate_results(results)
```

#### 架构模式 - 焦点小组
```python
class FocusGroupSession:
    def __init__(self, topic, participants):
        self.topic = topic
        self.participants = participants
        self.workflow = self._build_workflow()

    def _build_workflow(self):
        """构建焦点小组工作流"""
        return Workflow(
            steps=[
                # Step 1: 主持人提问
                WorkflowStep(
                    name="host_question",
                    agent=self.host_agent
                ),
                # Step 2: 参与者并行回答
                WorkflowStep(
                    name="participant_responses",
                    agents=self.participant_agents,
                    execution="parallel"
                ),
                # Step 3: 洞察提取
                WorkflowStep(
                    name="extract_insights",
                    agent=self.insight_agent
                )
            ]
        )

    async def run_round(self, host_question):
        """执行一轮讨论"""
        return await self.workflow.execute(input=host_question)
```

---

### 2.3 SmolaAgents（场景四）

#### 核心特点
- **Manager + Managed Agents**：层级代理架构
- **@tool 装饰器**：简洁的工具定义
- **灵活流程编排**：支持动态任务分配

#### 架构模式 - 受众生成流水线
```python
from smolagents import CodeAgent, ToolCallingAgent, tool, ManagedAgent

# 定义工具
@tool
def generate_basic_info(description: str) -> dict:
    """根据描述生成受众基础信息"""
    # 实现逻辑
    pass

@tool
def generate_personality(basic_info: dict) -> dict:
    """生成人格特征"""
    # 实现逻辑
    pass

@tool
def generate_behavior_patterns(personality: dict) -> dict:
    """生成行为模式"""
    # 实现逻辑
    pass

# 专业 Agent 定义
basic_info_agent = ManagedAgent(
    agent=ToolCallingAgent(tools=[generate_basic_info]),
    name="basic_info_generator",
    description="生成受众基础人口统计信息"
)

personality_agent = ManagedAgent(
    agent=ToolCallingAgent(tools=[generate_personality]),
    name="personality_generator",
    description="生成心理人格特征"
)

behavior_agent = ManagedAgent(
    agent=ToolCallingAgent(tools=[generate_behavior_patterns]),
    name="behavior_generator",
    description="生成消费行为模式"
)

# Manager Agent 编排
manager = ToolCallingAgent(
    tools=[],
    managed_agents=[basic_info_agent, personality_agent, behavior_agent],
    system_prompt="""你是受众画像生成管理者。
    按以下顺序调用专业 Agent：
    1. basic_info_generator - 生成基础信息
    2. personality_generator - 生成人格特征
    3. behavior_generator - 生成行为模式
    最后整合所有结果返回完整画像。"""
)
```

---

## 3. 数据架构

### 3.1 核心数据模型

```python
# 受众画像数据结构
AudienceProfile = {
    "user_id": str,           # UUID
    "name": str,

    # 基础信息
    "demographics": {
        "age": int,
        "gender": str,
        "location": str,
        "education": str,
        "income_level": str
    },

    # 职业信息
    "professional": {
        "industry": str,
        "position": str,
        "company_size": str,
        "work_experience": int,
        "career_goals": str
    },

    # 人格特征
    "personality": {
        "personality_type": str,      # MBTI/Big Five
        "communication_style": str,
        "core_traits": list,
        "key_strengths": list,
        "key_weaknesses": list,
        "behavioral_patterns": list
    },

    # 生活方式
    "lifestyle": {
        "hobbies": list,
        "values": list,
        "brand_preferences": list,
        "media_consumption": str,
        "decision_making_style": str
    }
}

# 问卷定义
SurveyDefinition = {
    "survey_id": str,
    "title": str,
    "questions": [
        {
            "id": str,
            "type": str,          # single_choice/multiple_choice/open_ended
            "content": str,
            "options": list       # 选择题选项
        }
    ]
}

# 焦点小组定义
FocusGroupDefinition = {
    "focus_group_id": str,
    "title": str,
    "topic": str,
    "background": str,
    "research_objectives": list,
    "participants": list,         # 参与者ID列表
    "questions_json": list        # SPIN问题框架
}
```

### 3.2 提示词模板系统

```python
# 提示词模板管理
class PromptTemplateManager:
    """统一管理各场景提示词模板"""

    TEMPLATES = {
        # 1对1访谈提示词
        "interview": {
            "system": "...",      # 从 backhour_ai 复用
            "spin_situation": "...",
            "spin_problem": "...",
            "spin_implication": "...",
            "spin_need_payoff": "..."
        },

        # 问卷回答提示词
        "survey": {
            "system": "...",
            "answer_guidance": "..."
        },

        # 焦点小组提示词
        "focus_group": {
            "system": "...",
            "discussion_style": "..."
        },

        # 画像生成提示词
        "generation": {
            "basic_info": "...",
            "personality": "...",
            "behavior": "..."
        }
    }
```

---

## 4. 并发与性能架构

### 4.1 并发控制策略

```python
# 批量场景并发控制
class ConcurrencyManager:
    """并发执行管理"""

    # 场景二：问卷投放（100-500并发）
    SURVEY_MAX_CONCURRENCY = 100
    SURVEY_BATCH_SIZE = 50

    # 场景三：焦点小组（100-200并发）
    FOCUS_GROUP_MAX_CONCURRENCY = 50
    FOCUS_GROUP_BATCH_SIZE = 20

    async def execute_batch(self, tasks, max_concurrency):
        """带限流的批量执行"""
        semaphore = asyncio.Semaphore(max_concurrency)

        async def limited_task(task):
            async with semaphore:
                return await task()

        return await asyncio.gather(*[
            limited_task(t) for t in tasks
        ])
```

### 4.2 任务管理模式

```python
# 异步任务管理（参考 backhour_ai 的 batch_task_manager）
class TaskManager:
    """防重复、支持轮询的任务管理"""

    def __init__(self):
        self.tasks = {}
        self.active_tasks = {}  # focus_group_id -> task_id

    async def get_or_create_task(self, task_key, task_params):
        """获取或创建任务（防重复）"""
        # 检查是否已有相同任务
        task_fingerprint = self._compute_fingerprint(task_params)

        if task_fingerprint in self.tasks:
            existing_task = self.tasks[task_fingerprint]
            if existing_task.status in ["pending", "processing"]:
                return existing_task, False  # 返回已存在任务

        # 创建新任务
        new_task = Task(
            task_id=str(uuid.uuid4()),
            params=task_params,
            status="pending"
        )
        self.tasks[task_fingerprint] = new_task
        return new_task, True
```

---

## 5. 错误处理与重试

### 5.1 统一错误处理

```python
class ErrorHandler:
    """统一错误处理"""

    # 重试配置
    MAX_RETRIES = 3
    RETRY_DELAY = 1.0
    EXPONENTIAL_BACKOFF = True

    async def with_retry(self, func, *args, **kwargs):
        """带重试的执行"""
        for attempt in range(self.MAX_RETRIES):
            try:
                return await func(*args, **kwargs)
            except RateLimitError:
                delay = self.RETRY_DELAY * (2 ** attempt)
                await asyncio.sleep(delay)
            except Exception as e:
                if attempt == self.MAX_RETRIES - 1:
                    raise
                logger.warning(f"Attempt {attempt + 1} failed: {e}")
```

### 5.2 错误隔离

```python
# 单个失败不影响整体
async def batch_with_isolation(tasks):
    """隔离执行，收集所有结果（含失败）"""
    results = []

    for task in tasks:
        try:
            result = await task()
            results.append({"success": True, "data": result})
        except Exception as e:
            results.append({"success": False, "error": str(e)})

    return results
```

---

## 6. 目录结构设计

```
siry_ai_research/
├── README.md
├── pyproject.toml
├── requirements.txt
│
├── docs/                           # 文档目录
│   ├── 01-项目需求文档.md
│   ├── 02-技术架构文档.md
│   ├── 03-设计文档.md
│   └── 04-API示例文档.md
│
├── src/
│   ├── __init__.py
│   │
│   ├── scenarios/                  # 四大场景实现
│   │   ├── __init__.py
│   │   ├── interview/              # 场景一：1对1访谈
│   │   │   ├── __init__.py
│   │   │   ├── agent.py            # Claude Agent SDK 实现
│   │   │   ├── mcp_tools.py        # MCP 工具定义
│   │   │   └── prompts.py          # 访谈提示词
│   │   │
│   │   ├── survey/                 # 场景二：问卷投放
│   │   │   ├── __init__.py
│   │   │   ├── deployment.py       # Agno 批量投放
│   │   │   ├── aggregator.py       # 结果聚合
│   │   │   └── prompts.py          # 问卷提示词
│   │   │
│   │   ├── focus_group/            # 场景三：焦点小组
│   │   │   ├── __init__.py
│   │   │   ├── session.py          # Agno 会话管理
│   │   │   ├── workflow.py         # 工作流定义
│   │   │   └── prompts.py          # 焦点小组提示词
│   │   │
│   │   └── generation/             # 场景四：受众生成
│   │       ├── __init__.py
│   │       ├── pipeline.py         # SmolaAgents 流水线
│   │       ├── agents.py           # 专业 Agent 定义
│   │       └── prompts.py          # 生成提示词
│   │
│   ├── core/                       # 核心模块
│   │   ├── __init__.py
│   │   ├── models.py               # 数据模型
│   │   ├── prompts.py              # 统一提示词管理
│   │   └── config.py               # 配置管理
│   │
│   └── utils/                      # 工具模块
│       ├── __init__.py
│       ├── concurrency.py          # 并发控制
│       ├── task_manager.py         # 任务管理
│       └── error_handler.py        # 错误处理
│
├── tests/                          # 测试目录
│   ├── __init__.py
│   ├── test_interview.py
│   ├── test_survey.py
│   ├── test_focus_group.py
│   └── test_generation.py
│
└── examples/                       # 示例脚本
    ├── interview_example.py
    ├── survey_example.py
    ├── focus_group_example.py
    └── generation_example.py
```

---

## 7. 依赖与环境

### 7.1 核心依赖

```toml
[project]
name = "siry-ai-research"
version = "0.1.0"
requires-python = ">=3.10"

dependencies = [
    # Claude Agent SDK
    "anthropic>=0.40.0",

    # Agno Framework
    "agno>=0.1.0",

    # SmolaAgents
    "smolagents>=0.1.0",

    # 通用依赖
    "pydantic>=2.0.0",
    "asyncio>=3.4.3",
    "python-dotenv>=1.0.0",
]
```

### 7.2 环境变量

```bash
# .env 配置
ANTHROPIC_API_KEY=sk-ant-xxx          # Claude API
OPENAI_API_KEY=sk-xxx                 # OpenAI API (备用)
OPENROUTER_API_KEY=xxx                # OpenRouter API

# 并发配置
SURVEY_MAX_CONCURRENCY=100
FOCUS_GROUP_MAX_CONCURRENCY=50

# 日志配置
LOG_LEVEL=INFO
```

---

## 8. 与 backhour_ai 的关系

### 8.1 复用内容

| 模块 | 复用来源 | 说明 |
|------|---------|------|
| 受众提示词 | `audience_agent._build_system_prompt_fallback_static()` | 完整复用对话风格指南 |
| SPIN框架 | `focus_group_service` | 复用问题生成逻辑 |
| 洞察提取 | `focus_group_service._analyze_messages_for_insights()` | 复用 DSPy Signature |

### 8.2 重构内容

| 模块 | 原实现 | 新实现 |
|------|--------|--------|
| 1对1访谈 | DSPy + SmolaAgents | Claude Agent SDK |
| 问卷投放 | asyncio.gather | Agno Teams |
| 焦点小组 | dspy.Parallel | Agno Workflows |
| 受众生成 | 单一流程 | SmolaAgents Manager |
